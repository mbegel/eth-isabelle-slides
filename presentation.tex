\documentclass{beamer}

\usepackage{mathtools}
\usepackage{pgf}
\usepackage{tikz}
\usepackage[normalem]{ulem}
\usetheme{Data61}
\renewcommand{\t}[1]{\texttt{#1}}

\input{0header}

\title{Program logic for terminating semantic of Ethereum bytecode}
\author{Myriam Begel}
\date{14 August 2017}
%\institute{ENS Cachan, Computer Science department}
%\subtitle{Verification}
\bibliographystyle{apalike}

\newlength{\textlarg}

%Tikz
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}
\tikzset{
	state/.style={
		rectangle,
		rounded corners,
		very thick,
		minimum height=2em,
		inner sep=2pt,
		text centered,node distance=1.3cm,
	},
}

\newcommand{\stkout}[1]{\textcolor{Data61 green}{\ifmmode\text{\sout{\ensuremath{#1}}}\else\sout{#1}\fi}}

\begin{document}
%%1
\maketitle


\begin{frame}{Overview}
	\centering
\begin{tikzpicture}[->,>=stealth']

% Position of QUERY 
% Use previously defined 'state' as layout (see above)
% use tabular for content to get columns/rows
% parbox to limit width of the listing
%Myreen's word

\node[state, 	% layout (defined above)
text width=10cm, 	% max text width
anchor=center,
draw=Data61 green] (Myreen) 
{\textcolor{Data61 green}{Program logic for machine code \cite{Myreen09}}};

% Hirai's work
\uncover<2->{
\node[state,    	% layout (defined above)
text width=10cm, 	% max text width
below of=Myreen, 	% Position is to the right of QUERY
anchor=center,
draw=Data61 plum
] (Hirai) 	% posistion relative to the center of the 'box'
{%
\color{Data61 plum}Implementation for EVM \cite{hirai2017defining}
};
\path (Myreen) 	edge 	(Hirai);}

% Terminating program logic
\uncover<3->{
\node[state,
below of=Hirai,
text width=10cm, 	% max text width
anchor=center,
draw=Data61 vermillion
] (Terminating) 
{\color{Data61 vermillion}
	Terminating program logic for EVM
};
\path (Hirai)     	edge 	(Terminating);}

% Inductive rules
\uncover<4->{
\node[state,
below of=Terminating,
text width=10cm, 	% max text width
anchor=center,
draw=Data61 ocean blue
] (Logic) 
{\color{Data61 ocean blue}
Inductive rules sound with respect to terminating logic
};
\path (Terminating)	edge	(Logic);}

% Automation
\uncover<5->{
\node[state,
below of=Logic,
text width=10cm,	% max text width
anchor=center,
draw=Data61 ocean blue
] (Auto) 
{\color{Data61 ocean blue} Automation of proofs and example
};
\path(Logic)       	edge  	(Auto);}

\end{tikzpicture}
\end{frame}

%%2
\part{Context}
\frame{\partpage}

%%3
\begin{frame}{Ethereum}
	\begin{columns}[c]
		\column{.6\textwidth}
		\begin{itemize}
			\item Blockchain platform
			\item Much more than a cryptocurrency
			\item Smart contracts : program running on a (Turing-complete) VM
		\end{itemize}
		\column{.4\textwidth}
		\includegraphics[scale=0.3]{Figures/ETHEREUM-LOGO_PORTRAIT_Black_small.png}
	\end{columns}
\end{frame}

%%4
\begin{frame}{Ethereum Virtual Machine \footnotesize{\cite{wood2014ethereum}}}
	\begin{columns}[c]
		\column{.6\textwidth}
		Most striking differences to JVM - ARM
		\begin{itemize}
			\item Termination by gas
			\item Dynamic JUMP
		\end{itemize}
		\column{.4\textwidth}
		\begin{tabular}{r l}
			1 & \texttt{JUMPI} \\
			2 & \texttt{PUSH~20}\\
			4 & \texttt{PUSH~10}\\
			6 & \texttt{JUMP}\\
			7 & \texttt{JUMPDEST}\\
			8 & \texttt{PUSH~30}\\
			10 & \texttt{JUMPDEST}\\
			11 & \texttt{JUMP}
		\end{tabular}
	\end{columns}
\end{frame}

%%5
\begin{frame}{Goal = trustworthy contracts}
	Most of smart contracts are critical (finance, ownership, ...)\\
	$\Rightarrow$ we contribute to a framework to formally specify and verify smart contracts
	\\ ~ \\
	\textbf{State of the art} \\
	EVM defined for Isabelle \cite{hirai2017defining} with a program logic inspired by \cite{Myreen09}
\end{frame}

%%6
\begin{frame}{Verification}
	At the bytecode level
	\begin{itemize}
		\item Strong garantees
		\item No gap in the trusted chain
		\item Current weak point = Solidity
		\item Several programing languages
	\end{itemize}
\end{frame}

%%7
\begin{frame}{Problem}
	\textbf{"\only<3>{\stkout{Non}} \only<1-2>{Non~} terminating" semantic }\\
	$\vdash\{P\}c\{Q\}$ if $Q$ holds \only<1-2>{\alert{at some point} in}\only<3>{{\color{Data61 green}at the end} of} the execution of $c$

	\begin{align*}
	\t{triple }&{ P~ c~ Q }\equiv\qquad\small{(*~c \t{ is a set of bytes}*)}\\
	&~\forall cctx~ ir~ R.\\
	&\quad{(P \wedge^* \t{code } c \wedge^* R)}\\
	&\qquad(\t{inst\_result\_as\_set } cctx~ ir) \Rightarrow\\
	&\quad
	\only<1-2>{~\alert{\exists} \alert{k.}}
	\only<3>{\stkout{\textcolor{black}{\exists k.}}}
	(Q \wedge^* \t{code }c \wedge^* R)\\
	&\qquad(\t{inst\_result\_as\_set }cctx~
	\only<1-2>{(\t{program\_sem   } cctx~ \alert{k}~ir))}
	\only<3>{(\t{program\_sem\textcolor{Data61 green}{\_t} } cctx~ \stkout{\textcolor{black}{k}}~ir))}
	\end{align*}

	\uncover<2>{\textbf{We can do better}\\}
	\uncover<3>{Termination of $\texttt{program\_sem\_t}$ proved by Sidney \& Maksym}
\end{frame}

%%8
\part{Contributions}
\frame{\partpage}

%%9
\begin{frame}{Program logic}
	Terminating semantic : not compositional\\
	$\Rightarrow$ define 3 levels for the program logic
	\begin{itemize}
		\item<2-> Instructions ${\color{Data61 green}\vdash_{inst}}$
			\begin{itemize}
				\item one rule per instruction
				\item<5-> non-terminating semantic with 1 step
			\end{itemize}
		\item<3-> Sequential block ${\color{Data61 plum}\vdash_{seq}}$
			\begin{itemize}
				\item unroll list of instructions
				\item<5-> non-terminating semantic with $n$ steps \\ $n=$ number of instructions
			\end{itemize}
		\item<4-> Connect blocks ${\color{Data61 ocean blue}\vdash_{blocks}}$
			\begin{itemize}
				\item jumps from one block to another
				\item<6-> terminating semantic
			\end{itemize}
	\end{itemize}
\end{frame}

%%10
\begin{frame}{Sequential blocks}
	\centering
	\only<-3>{
	\begin{tabular}{c r l c}
		&	\uncover<2->{0}	&	OR&\\
		&	\uncover<2->{1}	&	ADD&\\
		\uncover<4->{0}&	\uncover<2->{2}	&	SWAP1& 	\uncover<4->{Next}\\
		&	\uncover<2->{3}	&	\color<3->{Data61 green}JUMPDEST&\\
		&	\uncover<2->{4}	&	MLOAD&\\
		&	\uncover<2->{5}	&	POP&\\
		\uncover<4->{3}&	\uncover<2->{6}	&	\color<3->{Data61 green}JUMP& 	\uncover<4->{Jump}\\
		&	\uncover<2->{7}	&	DUP3&\\
		&	\uncover<2->{8}	&	PUSH 0&\\
		&	\uncover<2->{10}	&	ISZERO&\\
		\uncover<4->{7}&	\uncover<2->{11}	&	\color<3->{Data61 green}JUMPI& 	\uncover<4->{Jumpi}\\
		&	\uncover<2->{12}	&	POP&\\
		\uncover<4->{11}&	\uncover<2->{13}	&	\color<3->{Data61 green}RETURN& 	\uncover<4->{Terminal}\\
		\uncover<4->{14}&	\uncover<2->{14}	&	AND	& 	\uncover<4->{Next}
	\end{tabular}}
\setbeamercovered{transparent}
	\only<4->{
	\begin{tabular}{c r l c}
		&	0	&	OR&\\
		&	1	&	ADD&\\
		\visible<5->{0}&	2	&	SWAP1& 	\visible<5->{Next}\\
			\hline
		&	3	&	\color{Data61 green}JUMPDEST&\\
		&	4	&	MLOAD&\\
		&	5	&	POP&\\
		\visible<5->{3}&	\uncover<-4>{6}	&	\uncover<-4>{\color{Data61 green}JUMP}&	\visible<5->{Jump}\\
			\hline
		&	7	&	DUP3&\\
		&	8	&	PUSH 0&\\
		&	10	&	ISZERO&\\
		\visible<5->{7}&	\uncover<-4>{11}	&	\uncover<-4>{\color{Data61 green}JUMPI}&	\visible<5->{Jumpi}\\
			\hline
		&	12	&	POP&\\
		\visible<5->{12}&	13	&	\color{Data61 green}RETURN&	\visible<5->{Terminal}\\
			\hline
		\visible<5->{14}&	14	&	AND	& 	\visible<5->{Next}
	\end{tabular}}
\end{frame}
\setbeamercovered{}
%%11
\begin{frame}{Rule for POP}
	\begin{align*}
		{\color{Data61 green}\vdash_{inst}}&\\
		\{&{\color<2>{Data61 plum}\langle h \leq 1023 \wedge \texttt{Gbase} \leq g \rangle}~ \wedge^*\\
		&{\color<3>{Data61 dark mint}\texttt{continuing }} \wedge^*
		{\color<4>{Data61 vermillion}\texttt{program-counter n }} \wedge^*
		{\color<5>{Data61 gold}\texttt{gas-pred g }} \wedge^*\\
		&{\color<6>{Data61 fuchsia}\texttt{stack-height (Suc h) }} \wedge^*
		{\color<6>{Data61 fuchsia}\texttt{stack h x }} \wedge^*
		{\color<7>{Data61 light forest}\texttt{rest}}
		\}\\
		(&\texttt{n, POP}) \\
		\{&{\color<3>{Data61 dark mint}\texttt{continuing }} \wedge^*
		{\color<4>{Data61 vermillion}\texttt{program-counter (n + 1) }} \wedge^*\\
		&{\color<5>{Data61 gold}\texttt{gas-pred (g - Gbase) }} \wedge^*
		{\color<6>{Data61 fuchsia}\texttt{stack-height h }} \wedge^*
		{\color<7>{Data61 light forest}\texttt{rest}}\}
	\end{align*}
\end{frame}

%%12
\begin{frame}{Rules for a sequential block}
	\[\frac{{\color{Data61 green}\vdash_{inst}} \{P\} x \{R\}
		\qquad {\color{Data61 plum}\vdash_{seq}} \{R\} xs \{Q\}}
	{{\color{Data61 plum}\vdash_{seq}} \{P\} (x\#xs) \{Q\}}\]

	\[\frac{\forall s.~P~s~\Rightarrow~Q~s}
	{{\color{Data61 plum}\vdash_{seq}} \{P\} [~] \{Q\}}\]
\end{frame}

%%13
\begin{frame}{Rule for Terminal and Next blocks}
	\[\frac{{\color{Data61 plum}\vdash_{seq}} \{P\} xs \{Q\}}
	{\texttt{blocks~}{\color{Data61 ocean blue}\vdash_{blocks}} \{P\} (n,xs,Terminal) \{Q\}}\]

	~\\~\\
	\centering
	$\frac{{\color{Data61 plum}\vdash_{seq}} \{P\} xs \{\texttt{pc } m \wedge^* R\}
		\quad \texttt{(m,ys,t)}\in \texttt{blocks}
		\quad \texttt{blocks~}{\color{Data61 ocean blue}\vdash_{blocks}} \{\texttt{pc } m \wedge^* R\} (m,ys,t) \{Q\}}
	{\texttt{blocks~}{\color{Data61 ocean blue}\vdash_{blocks}} \{P\} (n,xs,Next) \{Q\}}$
\end{frame}

%%14
\begin{frame}{Rule for a Jump block}
	\footnotesize
	$$\frac{{\color{Data61 plum}\vdash_{seq}} \{P\} xs \{R1\}
	\quad \begin{aligned}
	&\texttt{(m,ys,t)}\in \texttt{blocks}\\
	&\texttt{hd ys = (m, JUMPDEST)}\\
	\end{aligned}
	\quad \texttt{blocks~} {\color{Data61 ocean blue}\vdash_{blocks}} \{R2\} (m,ys,t) \{Q\}}
	{\texttt{blocks~}{\color{Data61 ocean blue}\vdash_{blocks}} \{P\} (n,xs,Jump) \{Q\}}$$
	\small
	\uncover<2>{
	\begin{align*}
	R1 = ~& {\color{Data61 plum}\langle h \leq 1023 \wedge \color{Data61 plum}\texttt{Gmid} \leq g \rangle}~ \wedge^* 
	{\color{Data61 dark mint}\texttt{continuing }} \wedge^*
	{\color{Data61 gold}\texttt{gas-pred g }} \wedge^*\\
	&{\color{Data61 vermillion}\texttt{program-counter (n + inst-size-list xs) }}\wedge^*\\
	&{\color{Data61 fuchsia}\texttt{stack-height (Suc h) }} \wedge^*
	{\color{Data61 fuchsia}\texttt{stack h m }} \wedge^*
	{\color{Data61 light forest}\texttt{rest}}\\
	\end{align*}
	\begin{align*}
	R2 = ~&{\color{Data61 dark mint}\texttt{continuing }} \wedge^*
	{\color{Data61 gold}\texttt{gas-pred (g - Gmid) }} \wedge^*\\
	&{\color{Data61 vermillion}\texttt{program-counter m }}\wedge^*
	{\color{Data61 fuchsia}\texttt{stack-height h }} \wedge^*
	{\color{Data61 light forest}\texttt{rest}}\\
	\end{align*}
	}
\end{frame}

%%15
\begin{frame}{Rule for a Jumpi block}
	\footnotesize
	\hspace*{-20pt}
	$\tfrac{
		\begin{aligned}
		\texttt{hd }&\texttt{ys = (m, JUMPDEST)}&\\
		& \texttt{(m,ys,t)}\in \texttt{bl}
		&c \neq 0 \Rightarrow \texttt{bl}{\color{Data61 ocean blue}\vdash_{blocks}} \{\texttt{pc } m \wedge^* R2\} (m,ys,t) \{Q\}
		\\
		{\color{Data61 plum}\vdash_{seq}} \{P\} xs \{R1\} \quad
		&\texttt{(p,zs,t')}\in \texttt{bl}
		&c=0 \Rightarrow\texttt{bl}{\color{Data61 ocean blue}\vdash_{blocks}} \{\texttt{pc } p \wedge^* R2\} (p,zs,t') \{Q\}
		\end{aligned}
		}
	{\begin{aligned}\texttt{bl~}{\color{Data61 ocean blue}\vdash_{blocks}} \{P\} (n,xs,Jumpi) \{Q\}\end{aligned}}$
	\
	\uncover<2>{
	\begin{align*}
	R1 = ~& {\color{Data61 plum}\langle h \leq 1022 \wedge \color{Data61 plum}\texttt{Ghigh} \leq g \rangle}~ \wedge^*
	{\color{Data61 dark mint}\texttt{continuing }} \wedge^*\\
	&{\color{Data61 vermillion}\texttt{program-counter (p - 1) }}\wedge^*
	{\color{Data61 gold}\texttt{gas-pred g }} \wedge^*\\
	&{\color{Data61 fuchsia}\texttt{stack-height (h + 2) }} \wedge^*
	{\color{Data61 fuchsia}\texttt{stack (h+1) m }} \wedge^*
	{\color{Data61 fuchsia}\texttt{stack h c }} \wedge^*
	{\color{Data61 light forest}\texttt{rest}}\\
	\end{align*}
	\begin{align*}
	R2 = ~&{\color{Data61 dark mint}\texttt{continuing }} \wedge^*
	{\color{Data61 gold}\texttt{gas-pred (g - Ghigh) }} \wedge^*\\
	&{\color{Data61 fuchsia}\texttt{stack-height h }} \wedge^*
	{\color{Data61 light forest}\texttt{rest}}\\
	\end{align*}
	}
\end{frame}

%%16
\begin{frame}{Soundness}
	\begin{gather*}
		0<  \vert\t{c}\vert < 2^{256} \Rightarrow\\
		{\t{build\_blocks }c~{\color{Data61 ocean blue}\vdash_\t{blocks}} \{P\}~(fst\_block)~\{Q\}}\Rightarrow\\
		{\color{Data61 dark mint}\Vdash} \{P\}~(\t{set } c)~\{Q\}
	\end{gather*}
	${\color{Data61 dark mint}\Vdash}$ = terminating semantic for bytecode
\end{frame}

\begin{frame}{Verification of a simple contract}
		\ttfamily
		\footnotesize
	\begin{columns}[c]
		\column{.46\textwidth}
		\textcolor{Data61 ocean blue}{contract} D \{ \\
		\quad	\textcolor{Data61 midnight blue}{uint} owner;\\
		\quad	\textcolor{Data61 midnight blue}{mapping(uint $\Rightarrow$ uint)} addrs;\\
			
		\quad	\textcolor{Data61 ocean blue}{function} D(\textcolor{Data61 midnight blue}{uint} v) \{\\
		\quad\quad	owner = uint(msg.sender);\\
		\quad\quad	addrs[owner] = v;\\
		\quad	\}\\
		\quad	\textcolor{Data61 ocean blue}{function} dispatch1(\textcolor{Data61 midnight blue}{uint} a)\\
		\quad	\textcolor{Data61 ocean blue}{returns} (\textcolor{Data61 midnight blue}{uint}) \{\\
		\quad\quad	return a;\\
		\quad	\}\\
		\quad	\textcolor{Data61 ocean blue}{function} dispatch2()\\
		\quad	\textcolor{Data61 ocean blue}{returns} (\textcolor{Data61 midnight blue}{uint}) \{\\
		\quad\quad	{return} (2);\\
		\quad	\}\\
		\}\\
		
		\column{.6\textwidth}
		\textcolor{Data61 dark mint}{definition} return$\_$action' ::\\
		"32 word $\Rightarrow$ 256 word $\Rightarrow$ contract$\_$action" \textcolor{Data61 dark mint}{where}\\
		"return$\_$action' hash x = \\
		(\textcolor{Data61 dark mint}{if} hash = dispatch1$\_$hash \textcolor{Data61 dark mint}{then}\\
		ContractReturn x)\\
		\textcolor{Data61 dark mint}{else} (\textcolor{Data61 dark mint}{if} hash = dispatch2$\_$hash \textcolor{Data61 dark mint}{then}\\
		ContractReturn 2\\
		\textcolor{Data61 dark mint}{else} ContractFail [ShouldNotHappen]))"
	\end{columns}
\end{frame}

\begin{frame}{Proof automation}
	\footnotesize
	\ttfamily
	\textcolor{Data61 dark mint}{lemma}:\\
	"$\exists$ r. triple \\
	(program$\_$counter 0 $\wedge^*$ stack$\_$height 0 $\wedge^*$ sent$\_$data hash $\wedge^*$ sent$\_$value x $\wedge^*$
	memory$\_$usage 0 $\wedge^*$ continuing $\wedge^*$ gas$\_$pred 3000 $\wedge^*$ memory 64 x) $\wedge^*$
	memory 96 y)\\
	D\\
	(action (return$\_$action' z x) $\wedge^*$ r)"
\end{frame}

%%17
\begin{frame}{Summary - contributions}
	\begin{itemize}
		\item Defined function splitting bytecode into basic blocks in Isabelle
		\item Showed that function forms well-formed blocks
		\item Defined program logic for terminating semantics
		\item Proved soundness of program logic w.r.t. bytecode semantics
		\item Write a VCG to automatize proof
	\end{itemize}

\end{frame}

%%19
\part{Future work}
\frame{\partpage}

%%20
\begin{frame}{Specification of other contracts}
	\begin{itemize}
		\item Write rules for all the instructions
		\item Complete the soundness proof for them
		\item Specification of more complex contract
	\end{itemize}
\end{frame}

%%21
\begin{frame}{Control flow graph}
	CFG was the initial goal\\
	BUT problems with dynamic jumps\\
	HOWEVER proposition of static jumps and explicit function calls for EVM 1.5
	\\~\\
	\begin{itemize}
		\item Add edges to our blocks
		\item Detect loops
		\item More structured program
	\end{itemize}
\end{frame}

%%22
\frame[plain]{\thankspage{}{}{}{myriam.begel@ens-paris-saclay.fr}{}}

% \part \partpage not implemented yet
% thanks/question page not implemented

\bibliography{../bibli}

\end{document}